(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{339:function(t,s,a){"use strict";a.r(s);var e=a(6),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"usestate-usereducer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usestate-usereducer"}},[t._v("#")]),t._v(" useState / useReducer")]),t._v(" "),a("p",[t._v("useState 和 useReducer 都是关于状态值的提取和更新，从本质上来说没有区别，从实现上看，useState 是 useReducer 的一个简化版，其背后用的是同一套逻辑。")]),t._v(" "),a("h2",{attrs:{id:"react-hook-是如何保存状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook-是如何保存状态"}},[t._v("#")]),t._v(" React Hook 是如何保存状态")]),t._v(" "),a("p",[t._v("React 官方文档中提到，React Hook 保存状态的位置与类组件是一致的，但其实略有差别：")]),t._v(" "),a("ul",[a("li",[t._v("两者的状态值都被挂载在组件实例对象 FiberNode 的 memoizedState 属性中")]),t._v(" "),a("li",[t._v("两者保存状态值的数据结构完全不同。类组件是直接把 state 属性挂载在这个开发者自定义的对象保存到 memorizedState 属性中；而 Hook 是用链表来保存状态，memorizedState 属性保存的实际是这个链表的头指针")])]),t._v(" "),a("p",[t._v("我们来看看这个链表节点是什么样子的：")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// react-reconciler/src/ReactFiberHooks.js")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Hook")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  memoizedState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最新的状态值")]),t._v("\n  baseState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始状态值，如`useState(0)`，则初始值为0")]),t._v("\n  baseUpdate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Update"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  queue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateQueue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针")]),t._v("\n  next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Hook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向下一个链表节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("官方文档一直强调 React Hooks 的调用只能放在函数组件/自定义 Hooks 函数体的顶层，这是因为我们只能通过 Hooks 调用的顺序来与实际保存的数据结构来关联：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/7/1/17307e7bb3014026?imageslim",alt:""}})]),t._v(" "),a("p",[t._v("虽然上面一致都是以 useState 和 useReducer 来作为例子说明，但实际上所有 React Hooks 都是用这种链表的方式来保存的。")]),t._v(" "),a("h2",{attrs:{id:"react-hook-是如何更新状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook-是如何更新状态"}},[t._v("#")]),t._v(" React Hook 是如何更新状态")]),t._v(" "),a("p",[t._v("熟悉 Hook API 的话，我们都知道如何去更新状态，那么由 useState 返回的这个用来更新状态的函数（下文统称为 dispatcher）的运行原理是什么？")]),t._v(" "),a("p",[t._v("当我们每次调用 dispatcher 时，并不会立刻对状态值进行修改（对的，状态值的更新是异步的），而是创建一条修改操作--在对应 Hook 对象的 queue 属性挂载的链表上加一个新的节点：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/7/1/17307e7f74c14584?imageslim",alt:"\t"}})]),t._v(" "),a("p",[t._v("在下次执行函数组件，再次调用 useState 时，React 才会根据每个 Hook 上挂载的更新操作链表来计算最新的状态值。为什么需要把每次更新操作都记录下来，那是因为 Hook 支持这样的操作：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'b'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'c'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下次执行时就可以得到 name 的最新状态值为'abc'啦")]),t._v("\n")])])]),a("h1",{attrs:{id:"useeffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[t._v("#")]),t._v(" useEffect")]),t._v(" "),a("p",[t._v("useEffect 的保存方式和 useState / useReducer 类似，也是以链表的形式挂载在 FiberNode.updateQueue 中。")]),t._v(" "),a("p",[t._v("下面我们按照 mount 和 update 这两个组件的生命周期来阐述 useEffect 的执行原理：")]),t._v(" "),a("h2",{attrs:{id:"mount-阶段-mounteffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mount-阶段-mounteffect"}},[t._v("#")]),t._v(" mount 阶段：mountEffect")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("根据函数组件函数体中依次调用 useEffect 语句，构成一个链表并挂载在 "),a("code",[t._v("FiberNode.updateQueue")]),t._v(" 中，链表节点的数据结构为：")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" effect"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Effect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    tag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来标识依赖项有没有变动")]),t._v("\n    create"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用户使用useEffect传入的函数体")]),t._v("\n    destroy"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上述函数体执行后生成的用来清除副作用的函数")]),t._v("\n    deps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 依赖项列表")]),t._v("\n    next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("组件渲染完成后，遍历链表执行")])])]),t._v(" "),a("h2",{attrs:{id:"update-阶段-updateeffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update-阶段-updateeffect"}},[t._v("#")]),t._v(" update 阶段：updateEffect")]),t._v(" "),a("h3",{attrs:{id:"初始阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始阶段"}},[t._v("#")]),t._v(" 初始阶段")]),t._v(" "),a("p",[t._v("同样在依次调用 useEffect 语句 时，判断此时传入的依赖列表，与链表节点 "),a("code",[t._v("Effect.deps")]),t._v(" 中保存的是否一致（基本数据类型的值是否相同，对象的引用是否相同），如果一致，则在 "),a("code",[t._v("Effect.tag")]),t._v(" 标记上 "),a("code",[t._v("NoHookEffect")])]),t._v(" "),a("h3",{attrs:{id:"执行阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行阶段"}},[t._v("#")]),t._v(" 执行阶段")]),t._v(" "),a("p",[t._v("在每次组件渲染完成后，就会进入 useEffect 的执行阶段 "),a("code",[t._v("function commitHookEffectList()")])]),t._v(" "),a("ol",[a("li",[t._v("遍历链表")]),t._v(" "),a("li",[t._v("如果遇到 "),a("code",[t._v("Effect.tag")]),t._v(" 被标记上 "),a("code",[t._v("NoHookEffect")]),t._v(" 的节点则跳过")]),t._v(" "),a("li",[t._v("如果 "),a("code",[t._v("Effect.destroy")]),t._v(" 为函数类型，则需要执行该清除副作用的函数")]),t._v(" "),a("li",[t._v("执行 "),a("code",[t._v("Effect.create")]),t._v("，并将执行结果保存到 "),a("code",[t._v("Effect.destroy")]),t._v("（如果开发者没有配置 return，那么得到的自然是 undefined，也就是认为开发者对当前的 useEffect 没有需要清除的副作用）；注意由于闭包的缘故，"),a("code",[t._v("Effect.destory")]),t._v(" 实际上可以访问到本次 "),a("code",[t._v("Effect.create")]),t._v(" 函数作用域的变量")])]),t._v(" "),a("p",[t._v("我们注意到的一点是："),a("strong",[t._v("先清除上一轮的 effect，然后再执行本轮的 effect")])])])}),[],!1,null,null,null);s.default=n.exports}}]);