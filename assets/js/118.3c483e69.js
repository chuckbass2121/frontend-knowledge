(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{304:function(e,t,r){"use strict";r.r(t);var o=r(6),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"proxy-相比较于-defineproperty-的优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-相比较于-defineproperty-的优势"}},[e._v("#")]),e._v(" Proxy 相比较于 defineProperty 的优势")]),e._v(" "),r("p",[r("code",[e._v("Object.defineProperty")]),e._v(" 是监听对象的字段而非对象本身，因此对于动态插入对象的字段，它无能为了，只能手动为其设置设置监听属性。")]),e._v(" "),r("p",[e._v("同时，"),r("code",[e._v("Object.defineProperty")]),e._v(" 无法监听对象中数组的变化，因此其他基于 "),r("code",[e._v("Object.defineProperty")]),e._v(" 都对数组做了一定的 Hack 处理。")]),e._v(" "),r("p",[r("code",[e._v("Proxy")]),e._v(" 叫做代理器，它可以为一个对象设置代理，即监听对象本身，任何访问当前被监听的对象的操作，无论是对象本身亦或是对象的字段，都会被 Proxy 拦截，因此可以使用它来做一些双向绑定的操作。")]),e._v(" "),r("p",[e._v("鉴于兼容性的问题，目前仍然主要是使用 "),r("code",[e._v("Object.defineProperty")]),e._v(" 更多，但是随着 Vue/3 的发布，Proxy 应该会逐渐淘汰 "),r("code",[e._v("Object.defineProperty")]),e._v("。")])])}),[],!1,null,null,null);t.default=n.exports}}]);