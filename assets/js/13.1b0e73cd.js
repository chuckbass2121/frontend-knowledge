(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{202:function(s,t,e){s.exports=e.p+"assets/img/HTML-render.26026051.png"},203:function(s,t,e){s.exports=e.p+"assets/img/defer-async.b4d95074.jpg"},378:function(s,t,e){"use strict";e.r(t);var v=e(6),_=Object(v.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"页面加载渲染的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页面加载渲染的过程"}},[s._v("#")]),s._v(" 页面加载渲染的过程")]),s._v(" "),v("p",[v("img",{attrs:{src:e(202),alt:"html 页面加载渲染的过程"}})]),s._v(" "),v("ol",[v("li",[s._v("解析 HTML，生成 DOM 树（DOM）")]),s._v(" "),v("li",[s._v("解析 CSS，生成 CSSOM 树（CSSOM）")]),s._v(" "),v("li",[s._v("将 DOM 和 CSSOM 合并，生成渲染树（Render-Tree）")]),s._v(" "),v("li",[s._v("计算渲染树的布局（Layout）")]),s._v(" "),v("li",[s._v("将布局渲染到屏幕上（Paint）")])]),s._v(" "),v("p",[s._v("特点是:")]),s._v(" "),v("ol",[v("li",[s._v("顺序执行、并发加载")])]),s._v(" "),v("p",[s._v("HTML从上到下顺序执行，遇到需要加载的CSS，JS并发加载。")]),s._v(" "),v("p",[s._v("通过词法分析，通过HTML生成Token对象（当前节点的所有子节点生成后，才会通过next token获取到当前节点的兄弟节点），最终生成Dom Tree。\n浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以Chrome为例，并发上限为6个。\n优化点： 把CDN资源分布在多个域名下")]),s._v(" "),v("ul",[v("li",[s._v("html和css由GUI负责加载解析")]),s._v(" "),v("li",[s._v("JS脚本由JS引擎加载解析")]),s._v(" "),v("li",[s._v("GUI线程和JS线程是互斥的")])]),s._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[s._v("对于CSS:")]),s._v(" "),v("p",[s._v("CSS放在head中会阻塞页面的渲染（也就是说页面的渲染会等到css加载完成）,但不阻塞DOM解析")]),s._v(" "),v("p",[s._v("CSS阻塞JS的执行 （因为GUI线程和JS线程是互斥的，因为有可能JS会操作CSS）")]),s._v(" "),v("p",[s._v("CSS不阻塞外部脚本的加载（不阻塞JS的加载，但阻塞JS的执行，因为浏览器都会有预先扫描器）")])]),s._v(" "),v("li",[v("p",[s._v("对于JS:")]),s._v(" "),v("p",[s._v("直接引入的JS会阻塞页面的渲染（GUI线程和JS线程互斥），并且阻塞DOM解析")]),s._v(" "),v("p",[s._v("JS不阻塞资源的加载(这有赖于chrome的预加载机制)")]),s._v(" "),v("p",[s._v("JS顺序执行，阻塞后续JS逻辑的执行")])])]),s._v(" "),v("h2",{attrs:{id:"结论-html加载和渲染的一些优化点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结论-html加载和渲染的一些优化点"}},[s._v("#")]),s._v(" 结论：html加载和渲染的一些优化点")]),s._v(" "),v("ol",[v("li",[s._v("CSS样式放在head中，而不是body中")]),s._v(" "),v("li",[s._v("用link代替@import引入css")]),s._v(" "),v("li",[s._v("js脚本放在body标签尾部")]),s._v(" "),v("li",[s._v("合理使用js的异步加载能力")])]),s._v(" "),v("h3",{attrs:{id:"为什么-css样式放在head中-而不是body中"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么-css样式放在head中-而不是body中"}},[s._v("#")]),s._v(" 为什么 CSS样式放在head中，而不是body中")]),s._v(" "),v("ol",[v("li",[v("p",[s._v("css放在body标签尾部时, DOMTree构建完成之后便开始构建RenderTree, 并计算布局渲染网页,\n等加载解析完css之后, 开始构建CSSOMTree, 并和DOMTree重新构建RenderTree, 重新计算布局渲染网页.")])]),s._v(" "),v("li",[v("p",[s._v("css放在head标签中时, 先加载css, 之后解析css构建CSSOMTree,\n于此同时构建DOMTree, CSSOMTree和DOMTree都构建完毕之后开始构建RenderTree, 计算布局渲染网页。")]),s._v(" "),v("p",[s._v('对比两者, css放在head标签中比css放在body标签尾部少了一次构建RenderTree, 一次计算布局和一次渲染网页, 因此性能会更好;\n并且css放在body标签尾部时会在网页中短暂出现"裸奔"的HTML, 这不利于用户体验。')])])]),s._v(" "),v("p",[s._v("https://zhuanlan.zhihu.com/p/46387951")]),s._v(" "),v("h3",{attrs:{id:"用link代替-import引入css"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用link代替-import引入css"}},[s._v("#")]),s._v(" 用link代替@import引入css")]),s._v(" "),v("ol",[v("li",[v("p",[s._v("从属关系区别")]),s._v(" "),v("p",[s._v("@import是 CSS 提供的语法规则，只有导入样式表的作用；")]),s._v(" "),v("p",[s._v("link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。")])]),s._v(" "),v("li",[v("p",[s._v("加载顺序区别")]),s._v(" "),v("p",[s._v("加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。")])]),s._v(" "),v("li",[v("p",[s._v("兼容性区别")]),s._v(" "),v("p",[s._v("@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；")]),s._v(" "),v("p",[s._v("link标签作为 HTML 元素，不存在兼容性问题。")])]),s._v(" "),v("li",[v("p",[s._v("DOM可控性区别")]),s._v(" "),v("p",[s._v("可以通过 JS 操作 DOM ，插入link标签来改变样式；\n由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。")])]),s._v(" "),v("li",[v("p",[s._v("权重区别(该项有争议，下文将详解)")]),s._v(" "),v("p",[s._v("link引入的样式权重大于@import引入的样式。")])])]),s._v(" "),v("p",[s._v("@import的书写方式")]),s._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[s._v('<style type="text/css">\n@import \'style.css\' //Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别\n@import "style.css" //Windows IE4/ NS4, Macintosh IE4/NS4不识别\n@import url(style.css) //Windows NS4, Macintosh NS4不识别\n@import url(\'style.css\') //Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别\n@import url("style.css") //Windows NS4, Macintosh NS4不识别\n</style>\n')])])]),v("p",[s._v('其中，@import url(style.css) 和@import url("style.css")是最优的选择，兼容的浏览器最多。\n从字节优化的角度来看@import url(style.css)最值得推荐。')]),s._v(" "),v("p",[s._v("link的书写方式")]),s._v(" "),v("link",{attrs:{href:"style.css",rel:"stylesheet",type:"text/css"}}),s._v("  \n另外link还有其他的一些用途，比如引入图标\n"),v("link",{attrs:{rel:"shortcut icon",href:"/favicon.ico",type:"image/x-icon"}}),s._v(" "),v("h3",{attrs:{id:"js脚本放在body标签尾部"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js脚本放在body标签尾部"}},[s._v("#")]),s._v(" js脚本放在body标签尾部")]),s._v(" "),v("p",[s._v("CSS 和 JS 都会阻塞 HTML 的渲染，如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。\n所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。")]),s._v(" "),v("p",[s._v("但是为什么 CSS 还是要放在头部呢?\n因为如果先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、丑陋的.\n为了避免这种情况，所以要降 CSS 放在文件头部。\n不过目前这些操作都已经可以交给打包工具来完成。")]),s._v(" "),v("h3",{attrs:{id:"合理使用js的异步加载能力"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#合理使用js的异步加载能力"}},[s._v("#")]),s._v(" 合理使用js的异步加载能力")]),s._v(" "),v("h4",{attrs:{id:"异步加载方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步加载方式"}},[s._v("#")]),s._v(" 异步加载方式")]),s._v(" "),v("ul",[v("li",[s._v("defer")]),s._v(" "),v("li",[s._v("async")])]),s._v(" "),v("h4",{attrs:{id:"异步加载区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步加载区别"}},[s._v("#")]),s._v(" 异步加载区别")]),s._v(" "),v("ol",[v("li",[s._v("defer 是 HTML 解析完才会执行。\n如果是多个，按照加载的顺序依次执行。defer 脚本会在 DOMContentLoaded 和 load 事件之前执行")]),s._v(" "),v("li",[s._v("async 会在脚本加载完之后立即执行。\n如果是多个，执行顺序和加载顺序无关。async 会在 load 事件之前执行，\n但并不能确保与 DOMContentLoaded 的执行先后顺序")])]),s._v(" "),v("p",[v("img",{attrs:{src:e(203),alt:"异步加载脚本"}})])])}),[],!1,null,null,null);t.default=_.exports}}]);