(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{401:function(t,e,s){"use strict";s.r(e);var r=s(6),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"static-getderivedstatefromprops-props-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromprops-props-state"}},[t._v("#")]),t._v(" static getDerivedStateFromProps(props, state)")]),t._v(" "),s("h2",{attrs:{id:"官方翻译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#官方翻译"}},[t._v("#")]),t._v(" 官方翻译")]),t._v(" "),s("p",[t._v("https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops")]),t._v(" "),s("p",[t._v("getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。\n它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。")]),t._v(" "),s("p",[t._v("此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。\n例如，实现 "),s("Transition",[t._v(" 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。")])],1),t._v(" "),s("p",[t._v("派生状态会导致代码冗余，并使组件难以维护。 确保你已熟悉这些简单的替代方案：")]),t._v(" "),s("ul",[s("li",[t._v("如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate。")]),t._v(" "),s("li",[t._v("如果只想在 prop 更改时重新计算某些数据，请使用 memoization helper 代替。")]),t._v(" "),s("li",[t._v("如果你想在 prop 更改时“重置”某些 state，请考虑使组件完全受控或使用 key 使组件完全不受控 代替。")])]),t._v(" "),s("p",[t._v("此方法无权访问组件实例。如果你需要，可以通过提取组件 props 的纯函数及 class 之外的状态，在getDerivedStateFromProps()和其他 class 方法之间重用代码。")]),t._v(" "),s("p",[t._v("请注意，不管原因是什么，都会在每次渲染前触发此方法。\n这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。")]),t._v(" "),s("h2",{attrs:{id:"getderivedstatefromprops-存在的意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getderivedstatefromprops-存在的意义"}},[t._v("#")]),t._v(" getDerivedStateFromProps 存在的意义？")]),t._v(" "),s("p",[t._v("https://zhuanlan.zhihu.com/p/89494013")]),t._v(" "),s("p",[t._v("https://juejin.cn/post/6844903760305602568")])])}),[],!1,null,null,null);e.default=a.exports}}]);