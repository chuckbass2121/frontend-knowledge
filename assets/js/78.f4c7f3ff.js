(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{267:function(t,v,a){"use strict";a.r(v);var _=a(6),r=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"什么是多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是多态"}},[t._v("#")]),t._v(" 什么是多态")]),t._v(" "),a("blockquote",[a("p",[t._v("面向对象的三大特性：封装、继承、多态。")])]),t._v(" "),a("p",[t._v("从一定角度上看，封装和继承几乎都是为多态准备的。这是我们最后一个概念，也是最重要的知识点。")]),t._v(" "),a("h2",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),a("blockquote",[a("p",[t._v("多态：允许不同类的对象对同一消息作出响应。")])]),t._v(" "),a("p",[t._v("即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。")]),t._v(" "),a("p",[t._v("实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用起相应的方法。")]),t._v(" "),a("h2",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),a("p",[t._v("消除类型之间的耦合关系。现实中，关于多态的例子不胜枚举：比如按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。")]),t._v(" "),a("p",[t._v("再简单一点：坐公交车时，一个男的靠在你肩膀，你可能不爽，但是如果一个美女靠在你肩膀你就会很乐意，这就是多态的表现。")]),t._v(" "),a("h2",{attrs:{id:"表现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表现"}},[t._v("#")]),t._v(" 表现")]),t._v(" "),a("p",[t._v("多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好地解决了应用程序函数同名问题。")]),t._v(" "),a("p",[t._v("多态有两种表现形式：")]),t._v(" "),a("ul",[a("li",[t._v("重载")]),t._v(" "),a("li",[t._v("覆盖")])]),t._v(" "),a("h3",{attrs:{id:"重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[t._v("#")]),t._v(" 重载")]),t._v(" "),a("blockquote",[a("p",[t._v("重载（overload），是发生在同一类中，与什么父类子类、继承毫无关系。")])]),t._v(" "),a("p",[t._v("标识一个函数除了函数名外，还有函数的参数（个数和类型），也就是说，一个类中可以有两个或更多的函数，叫同一个名字而它们的参数不同。")]),t._v(" "),a("p",[t._v("它们之间毫无关系，是不同的函数，只是它们的功能类似，所以才命名一样，增加可读性，仅此而已。")]),t._v(" "),a("h3",{attrs:{id:"覆盖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#覆盖"}},[t._v("#")]),t._v(" 覆盖")]),t._v(" "),a("blockquote",[a("p",[t._v("覆盖（override）是发生在子类中，也就是说必须有继承的情况下才有覆盖发生。")])]),t._v(" "),a("p",[t._v("我们知道继承一个类，就会继承了父类中全部属性方法。如果你感到某个方法不适合当前子类，功能要变，那就在这个子类中重新实现一遍这个方法。")]),t._v(" "),a("p",[t._v("这样在调用这个方法的时候，就是执行子类的方法，父类中的方法就被覆盖了（当然，覆盖的时候函数名和参数要和父类中完全一致）。")])])}),[],!1,null,null,null);v.default=r.exports}}]);